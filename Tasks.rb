# Дан целочисленный массив.
#    Вывести номер первого из тех его элементов, которые удовлетворяют двойному неравенству: A[0] < A[i] < A[-1].
#    Если таких элементов нет, то вывести [ ]
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.index { |i| a[0] < i && i < a[-1] }.first || []
# puts b
#
# Дан целочисленный массив. Вывести номер последнего из тех его элементов, которые удовлетворяют двойному
# неравенству: A[0] < A[i] < A[-1]. Если таких элементов нет, то вывести [ ].
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.select { |num| a[0] < num && num < a[-1] }.last || []
# puts b
#
# Дан целочисленный массив. Преобразовать его, прибавив к четным числам первый элемент.
# Первый и последний элементы массива не изменять.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.each.with_index { |num, index| (a[index] = num + a[0]) if index != 0 && num.even? && index != a.length - 1}
# puts b.inspect

# Дан целочисленный массив.
# Преобразовать его, прибавив к четным числам последний элемент. Первый и последний элементы массива не изменять.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.each.with_index { |num, index| (a[index] = num + a[-1]) if index != 0 && num.even? && index != a.length - 1}
# puts b.inspect
#
# Дан целочисленный массив.
# Преобразовать его, прибавив к нечетным числам последний элемент. Первый и последний элементы массива не изменять.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.each.with_index { |num, index| (a[index] = num + a[-1]) if index != 0 && num.odd? && index != a.length - 1}
# puts b.inspect
#
# Дан целочисленный массив. Заменить все положительные элементы на значение минимального.
# a = [1, 7, 4, -5, 2, 1, 6, 4]
# b = a.each.with_index{ |num, index| (a[index] = a.min) }
# puts b.inspect
#
# Дан целочисленный массив. Заменить все отрицательные элементы на значение минимального
# a = [1, 7, -4, -5, 2, 1, 6, 4]
# b = a.each.with_index{ |num, index| (a[index] = a.min) if num < 0}
# puts b.inspect
#
# Дан целочисленный массив. Осуществить циклический сдвиг элементов массива влево на одну позицию.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.rotate
# puts b.inspect
#
# Дан целочисленный массив. Осуществить циклический сдвиг элементов массива вправо на одну позицию.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.rotate(-1)
# puts b.inspect
#
# Дан целочисленный массив. Проверить, образуют ли элементы арифметическую прогрессию.
# Если да, то вывести разность прогрессии, если нет - вывести nil.
# def check_progression(massive)
#   a = massive
#   value = a[1] - a[0]
#   for num, index in a.each_with_index
#     # puts num, index
#     if index != 0 && index != a.length - 1
#       if num - a[index-1] == a[index+1] - num && value == num - a[index-1]
#       else
#         value = nil
#       break
#         end
#     end
#   end
#   value
# end
#
# puts check_progression([1, 4, 7, 10, 13]).inspect
#
# Дан целочисленный массив. Найти количество его локальных максимумов
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# maximums = 0
# a.each_cons(3){ |a, b, c| (maximums += 1) if b > a && b > c }
# puts maximums
#
# Дан целочисленный массив. Найти максимальный из его локальных максимумов.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.select.with_index{ |num, index| index != 0 && index != a.length-1 && num > a[index-1] && num > a[index+1]}.max
# puts b.inspect
#
# Дан целочисленный массив. Определить количество участков, на которых его элементы монотонно возрастают.
# def number_sites(massive)
#   current_step = nil
#   number_of_sites = 0
#   massive.each_cons(3) do |a, b, c|
#     if b-a == c-b
#       if current_step.nil?
#         current_step = b-a
#         number_of_sites += 1
#       end
#     else
#       current_step = nil
#       end
#     end
#   number_of_sites
# end
# puts number_sites([1, 7, 4, 5, 6, 2, 1, 2, 3, 4, 4, 6, 8])
#
# Дано вещественное число R и массив вещественных чисел. Найти элемент массива, который наиболее близок к данному числу.
# def closer_number(massive, number)
#   difference = nil
#   elem_index = nil
#   massive.each.with_index do |x, index|
#     if x != number
#       if difference.nil?
#         difference = (x-number).abs
#         end
#       z = (x - number).abs
#       if z < difference
#         difference = z
#         elem_index = index
#       end
#     end
#   end
#   elem_index
# end
#
#
# puts closer_number([1, 7, 4, 5, 6, 2, 1, 2, 3, 4, 4, 6, 8], 10)
#
# or
# my_array = [1, 7, 4, 5, 6, 2, 1, 2, 3, 4, 4, 6, 8]
# number = 10
# puts my_array.min_by{|x| (number-x).abs}
#
# Дан целочисленный массив. Преобразовать его, вставив перед каждым положительным элементом нулевой элемент
# a = [1, 7, 4, 5, 6, 2, -1, -2, -3, 4, 4, 6, 8]
# def update_massive(massive)
#   mutable_massive = massive.dup
#   nomutable_massive = massive.dup
#   index_change_counter = 0
#   nomutable_massive.each.with_index do |num, index|
#       if num > 0
#         mutable_massive.insert(index+index_change_counter, nomutable_massive[0])
#         index_change_counter +=1
#       end
#   end
#   mutable_massive
# end
#
# puts update_massive(a).inspect
#
# Дан целочисленный массив. Упорядочить его по возрастанию
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# a.sort!
# puts a.inspect
#
# Дан целочисленный массив. Упорядочить его по убыванию.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# a.sort!.reverse!
# puts a.inspect
#
# Дан целочисленный массив.
# Вывести индексы массива в том порядке, в котором соответствующие им элементы образуют убывающую последовательность.
#
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# my_var = []
# a.each.with_index{ |num, index| my_var.push([num, index])}
# my_var.sort_by! {|x| -x[0]}
# my_var.each{|y| puts y[1]}
#
# Дан целочисленный массив. Найти индекс минимального элемента.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# p a.each.with_index.min[1]
#
# Дан целочисленный массив. Найти индекс первого минимального элемента.
# a = [5, 1, 7, 4, 5, 2, 1, 6, 4]
# puts a.index(a.min)
#
# Дан целочисленный массив. Найти индекс последнего минимального элемента
#
# a = [1,2, 3, 5, 5, 1, 1, 2, 3]
# x = a.min
# z = a.rindex(x)
#
# Дан целочисленный массив. Найти количество минимальных элементов.
# a = [1,2, 3, 5, 5, 1, 1, 2, 3]
# p a.select{|x| x==a.min}.length
#
# Дан целочисленный массив. Найти минимальный четный элемент.
#
# a = [1,2, 3, 5, 5, 1, 6, 1, 2, 3]
# p a.select{|x| x % 2 == 0}.min
#
# Дан целочисленный массив и интервал a..b. Найти минимальный из элементов в этом интервале.
# m = [1,2, 3, 5, 5, 3, 6, 1, 2, 3]
# a,b = 3,5
# p m[a..b].min
#
# Дан целочисленный массив. Найти количество элементов, расположенных перед первым минимальным.
# a = [5, 1, 7, 4, 5, 2, 1, 6, 4]
# puts a.index(a.min)
#
# Дан целочисленный массив. Найти количество элементов, расположенных после первого максимального
# a = [5, 1, 7, 4, 5, 2, 1, 7, 6, 4]
# puts a.size - a.index(a.max) - 1
#
# Дан целочисленный массив. Найти индекс первого экстремального (то есть минимального или максимального) элемента.
# a = [7, 1, 4, 5, 2, 1, 7, 6, 4]
# puts(if a.index(a.min)-a.index(a.max) == -1
#        a.index(a.min)
#      else
#        a.index(a.max)
#      end)
#
# Дан целочисленный массив. Найти индекс последнего экстремального (то есть минимального или максимального) элемента.
# a = [7, 1, 4, 5, 2, 1, 7, 6, 4]
# puts( if a.rindex(a.min)-a.rindex(a.max) == -1
#         a.rindex(a.max)
#       else
#         a.rindex(a.min)
#       end)
#
# Дан целочисленный массив. Найти количество элементов, между первым и последним минимальным.
# a = [7, 1, 4, 5, 2, 1, 7, 6, 4]
# puts a.rindex(a.min) - a.index(a.min) - 1
#
# Дан целочисленный массив. Найти два наибольших элемента.
# a = [8, 1, 4, 5, 2, 1, 7, 6, 4, 8]
# p a.index(a.max)
# a.delete_at(a.index(a.max))
# p a.max
#
# Дан целочисленный массив. Найти максимальное количество подряд идущих минимальных элементов.
# a = [8, 1, 1, 1, 1, 4, 5, 2, 2,  1, 7, 6, 4, 8]
# p a.select.with_index{ |x, y| a.min == x && a[y+1] == x || a.min == x && a[y-1] == x && y > 0 }.length
#
# Дан целочисленный массив. Вывести вначале все его четные элементы, а затем - нечетные.
# a = [8, 1, 1, 1, 1, 4, 5, 2, 2, 1, 7, 6, 4, 8]
# p a.sort_by{|x| [x % 2 , x]}
# or
# p a.partition{|x| x.even? }.reduce{|x, y| x.concat(y)}
#
# Дан целочисленный массив. Проверить, чередуются ли в нем четные и нечетные числа.
# a = [8, 1, 2, 3, 5]
# p a.each_cons(2).all?{|x, y| x.even? && y.odd? || x.odd? && y.even? }
#
# Дано вещественное число R и массив вещественных чисел.
# Найти два элемента массива, сумма которых наиболее близка к данному числу.
# a = [2, 1.5, 1.8, 13.4, 6.2, 4, 8]
# r = 8.4
# #
# def closer_numbers(massive, number)
#   array_of_arrays = []# здесь будут храниться элементы и их индексы в виде массивов в массиве
#
#   my_array = []# здесь храняться суммы чисел, их индекс в этом массиве равен индексу в элементов в массиве array_of_arrays
#
#   msn = massive.dup# запасной массив
#
#   massive.each.with_index do |x, index|
#     msn.each.with_index do |y, second_index|
#       if index != second_index
#         my_array.push(x+y) # добавляем результат суммы всех двух чисел
#         array_of_arrays.push([x, index, y, second_index]) # добавляем их данные ( элементы и индексы)
#       end
#     end
#   end
#   my_var = my_array.min_by{|x| (number-x).abs} # находим ближайшую сумму к исходному числу
#   index_of_elements = my_array.index(my_var) # = смотрим на индекс этой суммы
#   p array_of_arrays[index_of_elements] # - индексы равны в обоих массивов теперь можно вывести и сами числа с их индексами
#
# end
#
# closer_numbers(a, r)
#
# Дан целочисленный массив. Удалить все элементы, встречающиеся менее двух раз.
# a = [2, 5, 1, 8, 13, 4, 6, 2, -4, 4, 8]
# p a.select{|x| a.count(x) > 1}
#
# Дан целочисленный массив. Найти среднее арифметическое модулей его элементов.
# a = [2, 5, 1, 8, 13, 4, 6, 2, -4, 4, 8]
# p a.inject{ |sum, n| sum + n.abs } / (a.length)
#
# Дано целое число. Найти сумму его цифр.
# a = 123
# p a.to_s.split('').map(&:to_i).inject{ |sum, n| sum + n }
#
# Дан целочисленный массив.
# Возвести в квадрат отрицательные элементы и в третью степень - положительные. Нулевые элементы - не изменять.
# a = [2, 5, 1, 8, 13, 4, 6, 2, -4, 4, 8]
# p a.map{|x| x > 0 ? x ** 3 : x ** 2  }
#
# Дан дипапазон a..b.
# Получить массив из чисел, расположенных в этом диапазоне (исключая сами эти числа),
# в порядке их возрастания, а также размер этого массива.
# a = 2
# b = 6
# p Array(a..b)
# p Array(a..b).length
#
# Дано число А и натуральное число N. Найти результат следующего выражения 1 + А + А*2 + А*3 + … + А*N.
# a = 5
# n = 3
# result = 1
# n.times { result += a*n; n-=1}
# p result
#
# Дано натуральное число N. Найти результат следующего произведения 1*2*…*N.
# n = 4
# result = 1
# n.times { result *= n ; n-=1}
# p result
#
# Дан целочисленный массив и число К.
# Если существует элемент, меньший К, то вывести true; в противном случае вывести false.
# a = [2, 5, 1, 8, 13, 4, 6, 2, -4, 4, 8]
# k = -5
# p !a.select{ |x| x < k ? true : false }.empty?
#
# Дан целочисленный массив и число К.
# Если все элементы массива меньше К, то вывести true; в противном случае вывести false.
# a = [2, 5, 1, 8, 13, 4, 6, 2, -4, 4, 8]
# k = 15
# p a.select{ |x| x < k ? false : true }.empty?
#
# Дан целочисленный массив. Вывести индексы элементов, которые меньше своего левого соседа, и количество таких чисел.
# a = [2, 5, 1, 8, 13, 4, 6, 2, -4, 4, 8]
# p a.select.with_index{|num, index| num < a[index-1] if index != 0 }.length
#
# Дан целочисленный массив.
# Если данный массив образует убывающую последовательность, то вывести nil,
# в противном случае вывести номер первого числа, нарушающего закономерность.
# a = [10, 7, 4, 1]
# p a.index(a[1..-1].find.with_index{|num, index| a[index] - num != a[0] - a[1]})
#
# Дан целочисленный массив, содержащий по крайней мере два нуля.
# Вывести сумму чисел из данного массива, расположенных между первыми двумя нулями.
# a = [2, 5, 0, 8, 13, 4, 0, 2, 4, 4, 0]
## p a[a.index(0)+1..a[(a.index(0)+1)..-1].index(0)+(a.index(0)+1)-1].inject{|sum, x| sum + x}
#
# Дан целочисленный массив. Поменять местами минимальный и максимальный элементы массива.
# a = [2, 5, 1, 8, 13, 4, 2, 4, 4]
# a[a.index(a.max)], a[a.index(a.min)] = a[a.index(a.min)], a[a.index(a.max)]
# p a
#
# Дан целочисленный массив.
# Переставить в обратном порядке элементы массива, расположенные между его минимальным и максимальным элементами.
# a = [2, 5, 1, 8, 4, 2, 4, 13]
# b = a[0..a.index(a.min)].concat(a[a.index(a.min)+1..a.index(a.max)-1].reverse!).concat(a[a.index(a.max)..-1])
# p b
#
#	Дано четырехзначное целое число. Необходимо проверить, является ли оно числом Армстронга.
# a = 153
# result = 0
# a.to_s.each_char{|x| result += x.to_i ** a.to_s.length}
# p result
#
# Идет k-я секунда года. Необходимо определить сколько полных месяцев и полных недель осталось до конца года.
# tn = Time::now
# p 12 - tn.month
# p Time::new(tn.year, 12, 31).strftime("%W").to_i - tn.strftime("%W").to_i
#
# Даны два числа. Необходимо найти их среднее геометрическое.
# a = 10
# b = 5
# p (a * b) ** 0.5
#
# Даны координаты некоторой точки A (на плоскости). Необходимо найти расстояние от точки A до начала координат.
# x = 5
# y = 5
# p Math.sqrt(x**2 + y**2)
#
# Дано четырехзначное число. Необходимо проверить, различны ли все четыре цифры этого числа.
# a = 1234
# b=a.to_s.split('')
# p b.uniq==b
#
# Дано натуральное число меньшее 256. Необходимо найти сумму всех нечетных битов этого числа.
# a = 193
# p a.to_s(2).split('').map{|x| x.to_i}.select.with_index{|num, index| index.odd?}.sum
#
# Дана строка. Необходимо найти общее количество русских символов.
# str = '4059405алдЛЛадплflgkflgk'
# str.scan(/[А-я]/).size
#
# Дана строка, состоящая из символов латиницы.
# Необходимо проверить, упорядочены ли строчные символы этой строки по возрастанию.
# str = "acBdeFc"
# a=str.scan(/[a-z]/)
# p a==a.sort
#
# Дана строка. Необходимо проверить, является ли она палиндромом.
# str = "a b c c b a"
# p str == str.reverse
#
# Дана строка. Необходимо перемешать все символы строки в случайном порядке.
# str = "a b c c b a"
# p str.split('').shuffle.join

# Дана строка в которой записаны слова через пробел.
# Необходимо перемешать в каждом слове все символы в случайном порядке кроме первого и последнего.
# str = "haha gogo lol okay go"
# p str.split(' ').map.with_index{|x, index| index != 0 && index != str.split(' ').length-1 ? x.split('').shuffle.join : x}.join(' ')
#
# Дана строка в которой содержатся цифры и буквы. Необходимо расположить все цифры в начале строки, а буквы -- в конце.
# str = "a2b4c5c6b7a"
# p str.split('').sort.join
#
# Дана строка в которой записаны слова через пробел.
# Необходимо упорядочить слова по количеству букв в каждом слове.
# str = "haha gogo lol okay go"
# p str.split(' ').sort_by{|x| x.length}
#
# Дана строка в которой записан путь к файлу. Необходимо найти имя файла без расширения.
# str = 'hello/ruby.rb'
## p str.scan(/(?!\/)(\w+)(?=\.\w+)/)
#
# Дана строка. Необходимо найти наибольшее количество идущих подряд цифр
# str = 'fgfglkfgl40950lfk405940594059'
# p str.scan(/(\d+)/).each.sort[0][0].length
#
# Дана строка. Необходимо найти все даты, которые описаны в виде "31 февраля 2007".
# str=(' flgkflgk flgk вдалвдал 31 февраля 2007')
# p str.scan(/(\d\d [\W]+ \d\d\d\d)/)