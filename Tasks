# Дан целочисленный массив.
#    Вывести номер первого из тех его элементов, которые удовлетворяют двойному неравенству: A[0] < A[i] < A[-1].
#    Если таких элементов нет, то вывести [ ]
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.index { |i| a[0] < i && i < a[-1] }.first || []
# puts b
#
# Дан целочисленный массив. Вывести номер последнего из тех его элементов, которые удовлетворяют двойному
# неравенству: A[0] < A[i] < A[-1]. Если таких элементов нет, то вывести [ ].
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.select { |num| a[0] < num && num < a[-1] }.last || []
# puts b
#
# Дан целочисленный массив. Преобразовать его, прибавив к четным числам первый элемент.
# Первый и последний элементы массива не изменять.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.each.with_index { |num, index| (a[index] = num + a[0]) if index != 0 && num.even? && index != a.length - 1}
# puts b.inspect

# Дан целочисленный массив.
# Преобразовать его, прибавив к четным числам последний элемент. Первый и последний элементы массива не изменять.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.each.with_index { |num, index| (a[index] = num + a[-1]) if index != 0 && num.even? && index != a.length - 1}
# puts b.inspect
#
# Дан целочисленный массив.
# Преобразовать его, прибавив к нечетным числам последний элемент. Первый и последний элементы массива не изменять.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.each.with_index { |num, index| (a[index] = num + a[-1]) if index != 0 && num.odd? && index != a.length - 1}
# puts b.inspect
#
# Дан целочисленный массив. Заменить все положительные элементы на значение минимального.
# a = [1, 7, 4, -5, 2, 1, 6, 4]
# b = a.each.with_index{ |num, index| (a[index] = a.min) }
# puts b.inspect
#
# Дан целочисленный массив. Заменить все отрицательные элементы на значение минимального
# a = [1, 7, -4, -5, 2, 1, 6, 4]
# b = a.each.with_index{ |num, index| (a[index] = a.min) if num < 0}
# puts b.inspect
#
# Дан целочисленный массив. Осуществить циклический сдвиг элементов массива влево на одну позицию.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.rotate
# puts b.inspect
#
# Дан целочисленный массив. Осуществить циклический сдвиг элементов массива вправо на одну позицию.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.rotate(-1)
# puts b.inspect
#
# Дан целочисленный массив. Проверить, образуют ли элементы арифметическую прогрессию.
# Если да, то вывести разность прогрессии, если нет - вывести nil.
# def check_progression(massive)
#   a = massive
#   value = a[1] - a[0]
#   for num, index in a.each_with_index
#     # puts num, index
#     if index != 0 && index != a.length - 1
#       if num - a[index-1] == a[index+1] - num && value == num - a[index-1]
#       else
#         value = nil
#       break
#         end
#     end
#   end
#   value
# end
#
# puts check_progression([1, 4, 7, 10, 13]).inspect
#
# Дан целочисленный массив. Найти количество его локальных максимумов
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# maximums = 0
# a.each_cons(3){ |a, b, c| (maximums += 1) if b > a && b > c }
# puts maximums
#
# Дан целочисленный массив. Найти максимальный из его локальных максимумов.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# b = a.select.with_index{ |num, index| index != 0 && index != a.length-1 && num > a[index-1] && num > a[index+1]}.max
# puts b.inspect
#
# Дан целочисленный массив. Определить количество участков, на которых его элементы монотонно возрастают.
# def number_sites(massive)
#   current_step = nil
#   number_of_sites = 0
#   massive.each_cons(3) do |a, b, c|
#     if b-a == c-b
#       if current_step.nil?
#         current_step = b-a
#         number_of_sites += 1
#       end
#     else
#       current_step = nil
#       end
#     end
#   number_of_sites
# end
# puts number_sites([1, 7, 4, 5, 6, 2, 1, 2, 3, 4, 4, 6, 8])
#
# Дано вещественное число R и массив вещественных чисел. Найти элемент массива, который наиболее близок к данному числу.
# def closer_number(massive, number)
#   difference = nil
#   elem_index = nil
#   massive.each.with_index do |x, index|
#     if x != number
#       if difference.nil?
#         difference = (x-number).abs
#         end
#       z = (x - number).abs
#       if z < difference
#         difference = z
#         elem_index = index
#       end
#     end
#   end
#   elem_index
# end
#
# puts closer_number([1, 7, 4, 5, 6, 2, 1, 2, 3, 4, 4, 6, 8], 10)
# Дан целочисленный массив. Преобразовать его, вставив перед каждым положительным элементом нулевой элемент
# a = [1, 7, 4, 5, 6, 2, -1, -2, -3, 4, 4, 6, 8]
# def update_massive(massive)
#   mutable_massive = massive.dup
#   nomutable_massive = massive.dup
#   index_change_counter = 0
#   nomutable_massive.each.with_index do |num, index|
#       if num > 0
#         mutable_massive.insert(index+index_change_counter, nomutable_massive[0])
#         index_change_counter +=1
#       end
#   end
#   mutable_massive
# end
#
# puts update_massive(a).inspect
#
# Дан целочисленный массив. Упорядочить его по возрастанию
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# a.sort!
# puts a.inspect
#
# Дан целочисленный массив. Упорядочить его по убыванию.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# a.sort!.reverse!
# puts a.inspect
#
# Дан целочисленный массив.
# Вывести индексы массива в том порядке, в котором соответствующие им элементы образуют убывающую последовательность.
#
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# my_var = []
# a.each.with_index{ |num, index| my_var.push([num, index])}
# my_var.sort_by! {|x| -x[0]}
# my_var.each{|y| puts y[1]}
#
# Дан целочисленный массив. Найти индекс минимального элемента.
# a = [1, 7, 4, 5, 2, 1, 6, 4]
# p a.each.with_index.min[1]
#
# Дан целочисленный массив. Найти индекс первого минимального элемента.
# a = [5, 1, 7, 4, 5, 2, 1, 6, 4]
# puts a.index(a.min)
#
# Дан целочисленный массив. Найти индекс последнего минимального элемента
#
# a = [1,2, 3, 5, 5, 1, 1, 2, 3]
# x = a.min
# z = a.rindex(x)
#
# Дан целочисленный массив. Найти количество минимальных элементов.
# a = [1,2, 3, 5, 5, 1, 1, 2, 3]
# p a.select{|x| x==a.min}.length
#
# Дан целочисленный массив. Найти минимальный четный элемент.
#
# a = [1,2, 3, 5, 5, 1, 6, 1, 2, 3]
# p a.select{|x| x % 2 == 0}.min
#
# Дан целочисленный массив и интервал a..b. Найти минимальный из элементов в этом интервале.
# m = [1,2, 3, 5, 5, 3, 6, 1, 2, 3]
# a,b = 3,5
# p m[a..b].min
#
# Дан целочисленный массив. Найти количество элементов, расположенных перед первым минимальным.
# a = [5, 1, 7, 4, 5, 2, 1, 6, 4]
# puts a.index(a.min)
#
# Дан целочисленный массив. Найти количество элементов, расположенных после первого максимального
# a = [5, 1, 7, 4, 5, 2, 1, 7, 6, 4]
# puts a.size - a.index(a.max) - 1
#
# Дан целочисленный массив. Найти индекс первого экстремального (то есть минимального или максимального) элемента.
# a = [7, 1, 4, 5, 2, 1, 7, 6, 4]
# puts(if a.index(a.min)-a.index(a.max) == -1
#        a.index(a.min)
#      else
#        a.index(a.max)
#      end)
#
# Дан целочисленный массив. Найти индекс последнего экстремального (то есть минимального или максимального) элемента.
# a = [7, 1, 4, 5, 2, 1, 7, 6, 4]
# puts( if a.rindex(a.min)-a.rindex(a.max) == -1
#         a.rindex(a.max)
#       else
#         a.rindex(a.min)
#       end)
#
# Дан целочисленный массив. Найти количество элементов, между первым и последним минимальным.
# a = [7, 1, 4, 5, 2, 1, 7, 6, 4]
# puts a.rindex(a.min) - a.index(a.min) - 1
#
# Дан целочисленный массив. Найти два наибольших элемента.
# a = [8, 1, 4, 5, 2, 1, 7, 6, 4, 8]
# p a.index(a.max)
# a.delete_at(a.index(a.max))
# p a.max
#
# Дан целочисленный массив. Найти максимальное количество подряд идущих минимальных элементов.
# a = [8, 1, 1, 1, 1, 4, 5, 2, 2,  1, 7, 6, 4, 8]
# p a.select.with_index{ |x, y| a.min == x && a[y+1] == x || a.min == x && a[y-1] == x && y > 0 }.length
#
# Дан целочисленный массив. Вывести вначале все его четные элементы, а затем - нечетные.
# a = [8, 1, 1, 1, 1, 4, 5, 2, 2,  1, 7, 6, 4, 8]
